{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/IdentityOApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OApp, Origin, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title IdentityOApp\n * @notice Cross-chain verification marker propagation via LayerZero v2\n * @dev Sends minimal verified flags between chains without PII\n */\ncontract IdentityOApp is OApp {\n    // Events\n    event VerificationSent(\n        address indexed user,\n        uint32 indexed dstEid,\n        bytes32 policyId,\n        bytes32 commitment,\n        uint256 expiry\n    );\n    event VerificationReceived(\n        address indexed user,\n        uint32 indexed srcEid,\n        bytes32 policyId,\n        bytes32 commitment,\n        uint256 expiry\n    );\n\n    // Structs\n    struct CrossChainVerification {\n        address user;\n        bytes32 policyId;\n        bytes32 commitment;\n        uint256 expiry;\n        uint32 sourceEid;\n        uint256 timestamp;\n        bool active;\n    }\n\n    // State\n    mapping(address => mapping(bytes32 => CrossChainVerification))\n        public verifications;\n    mapping(address => bytes32[]) public userPolicies;\n\n    // Errors\n    error InvalidMessage();\n    error VerificationExpired();\n\n    /**\n     * @notice Constructor\n     * @param _endpoint LayerZero endpoint address\n     * @param _owner Contract owner\n     */\n    constructor(address _endpoint, address _owner)\n        OApp(_endpoint, _owner)\n        Ownable(_owner)\n    {}\n\n    /**\n     * @notice Send verification to another chain\n     * @param dstEid Destination chain endpoint ID\n     * @param user User address\n     * @param policyId Policy identifier\n     * @param commitment Credential commitment hash\n     * @param expiry Expiration timestamp\n     * @param options LayerZero execution options\n     */\n    function sendVerification(\n        uint32 dstEid,\n        address user,\n        bytes32 policyId,\n        bytes32 commitment,\n        uint256 expiry,\n        bytes calldata options\n    ) external payable {\n        if (expiry <= block.timestamp) revert VerificationExpired();\n\n        bytes memory payload = abi.encode(\n            user,\n            policyId,\n            commitment,\n            expiry\n        );\n\n        _lzSend(\n            dstEid,\n            payload,\n            options,\n            MessagingFee(msg.value, 0),\n            payable(msg.sender)\n        );\n\n        emit VerificationSent(user, dstEid, policyId, commitment, expiry);\n    }\n\n    /**\n     * @notice Internal function to handle receiving messages from LayerZero\n     * @param origin Message origin details\n     * @param message Encoded verification data\n     */\n    function _lzReceive(\n        Origin calldata origin,\n        bytes32, /*guid*/\n        bytes calldata message,\n        address, /*executor*/\n        bytes calldata /*extraData*/\n    ) internal override {\n        (\n            address user,\n            bytes32 policyId,\n            bytes32 commitment,\n            uint256 expiry\n        ) = abi.decode(message, (address, bytes32, bytes32, uint256));\n\n        if (expiry <= block.timestamp) revert VerificationExpired();\n\n        // Store verification\n        verifications[user][policyId] = CrossChainVerification({\n            user: user,\n            policyId: policyId,\n            commitment: commitment,\n            expiry: expiry,\n            sourceEid: origin.srcEid,\n            timestamp: block.timestamp,\n            active: true\n        });\n\n        // Track user policies\n        userPolicies[user].push(policyId);\n\n        emit VerificationReceived(\n            user,\n            origin.srcEid,\n            policyId,\n            commitment,\n            expiry\n        );\n    }\n\n    /**\n     * @notice Check if user has valid cross-chain verification\n     * @param user User address\n     * @param policyId Policy identifier\n     * @return bool True if valid verification exists\n     */\n    function isVerified(address user, bytes32 policyId)\n        external\n        view\n        returns (bool)\n    {\n        CrossChainVerification memory v = verifications[user][policyId];\n        return v.active && v.expiry > block.timestamp;\n    }\n\n    /**\n     * @notice Get verification details\n     * @param user User address\n     * @param policyId Policy identifier\n     */\n    function getVerification(address user, bytes32 policyId)\n        external\n        view\n        returns (CrossChainVerification memory)\n    {\n        return verifications[user][policyId];\n    }\n\n    /**\n     * @notice Get all policy IDs for a user\n     * @param user User address\n     */\n    function getUserPolicies(address user)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return userPolicies[user];\n    }\n\n    /**\n     * @notice Quote the fee for sending a message\n     * @param dstEid Destination endpoint ID\n     * @param message Message payload\n     * @param options Execution options\n     * @param payInLzToken Whether to pay in LZ token\n     */\n    function quote(\n        uint32 dstEid,\n        bytes memory message,\n        bytes memory options,\n        bool payInLzToken\n    ) public view returns (MessagingFee memory fee) {\n        return _quote(dstEid, message, options, payInLzToken);\n    }\n}\n\n"
    },
    "contracts/interfaces/IVaultAnchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ninterface IVaultAnchor {\n    struct Commitment {\n        bytes32 commitment;\n        uint256 expiry;\n        uint256 timestamp;\n        bool revoked;\n    }\n\n    function addCommitment(bytes32 commitment, uint256 expiry) external;\n\n    function revokeCommitment(bytes32 commitment) external;\n\n    function isCommitmentValid(address user, bytes32 commitment)\n        external\n        view\n        returns (bool);\n\n    function getUserCommitments(address user)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getCommitment(address user, bytes32 commitment)\n        external\n        view\n        returns (Commitment memory);\n}\n\n"
    },
    "contracts/KycAirdrop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title KycAirdrop\n * @notice Demo dApp that gates airdrop claims using OmniPriv verifications\n * @dev Per OmniPriv 2.0 spec section 1 & 3: demonstrates KYC-gated action on Chain B\n * Example: \"Age  18 and not from blocked country\" to claim tokens\n */\ncontract KycAirdrop is Ownable, ReentrancyGuard {\n    // Events\n    event AirdropClaimed(\n        address indexed user,\n        bytes32 indexed userHash,\n        uint256 amount,\n        bytes32 policyId\n    );\n    event AirdropConfigured(\n        bytes32 indexed policyId,\n        uint256 amountPerUser,\n        uint256 totalSupply\n    );\n\n    // Structs\n    struct AirdropConfig {\n        bytes32 requiredPolicyId; // e.g., keccak256(\"AGE18_COUNTRY_ALLOWED\")\n        uint256 amountPerUser;\n        uint256 totalSupply;\n        uint256 claimed;\n        bool active;\n    }\n\n    // State\n    address public verifierContract; // OmniPrivVerifier address\n    AirdropConfig public airdropConfig;\n    mapping(address => bool) public hasClaimed;\n    mapping(bytes32 => address) public userHashToAddress; // Track user mapping\n\n    // Errors\n    error NotVerified();\n    error AlreadyClaimed();\n    error AirdropInactive();\n    error InsufficientSupply();\n    error TransferFailed();\n    error InvalidVerifier();\n\n    /**\n     * @notice Constructor\n     * @param _verifier OmniPrivVerifier contract address\n     * @param _owner Contract owner\n     */\n    constructor(address _verifier, address _owner)\n        Ownable(_owner)\n    {\n        if (_verifier == address(0)) revert InvalidVerifier();\n        verifierContract = _verifier;\n    }\n\n    /**\n     * @notice Configure the airdrop parameters\n     * @param policyId Required policy (e.g., \"AGE18_COUNTRY_ALLOWED\")\n     * @param amountPerUser Amount each user can claim\n     */\n    function configureAirdrop(\n        bytes32 policyId,\n        uint256 amountPerUser\n    ) external payable onlyOwner {\n        airdropConfig = AirdropConfig({\n            requiredPolicyId: policyId,\n            amountPerUser: amountPerUser,\n            totalSupply: msg.value,\n            claimed: 0,\n            active: true\n        });\n\n        emit AirdropConfigured(policyId, amountPerUser, msg.value);\n    }\n\n    /**\n     * @notice Claim airdrop tokens\n     * @dev User must have valid verification from OmniPrivVerifier\n     * @param userHash User's identity hash (from ZK proof)\n     * Per spec section 1: \"dApp calls isVerified(userHash, policyId); if true, action proceeds\"\n     */\n    function claim(bytes32 userHash) external nonReentrant {\n        if (!airdropConfig.active) revert AirdropInactive();\n        if (hasClaimed[msg.sender]) revert AlreadyClaimed();\n        \n        uint256 remaining = airdropConfig.totalSupply - airdropConfig.claimed;\n        if (remaining < airdropConfig.amountPerUser) revert InsufficientSupply();\n\n        // Core verification check per spec\n        (bool success, bytes memory data) = verifierContract.staticcall(\n            abi.encodeWithSignature(\n                \"isVerified(bytes32,bytes32)\",\n                userHash,\n                airdropConfig.requiredPolicyId\n            )\n        );\n\n        if (!success || !abi.decode(data, (bool))) {\n            revert NotVerified();\n        }\n\n        // Mark as claimed\n        hasClaimed[msg.sender] = true;\n        userHashToAddress[userHash] = msg.sender;\n        airdropConfig.claimed += airdropConfig.amountPerUser;\n\n        // Transfer tokens\n        (bool sent, ) = payable(msg.sender).call{value: airdropConfig.amountPerUser}(\"\");\n        if (!sent) revert TransferFailed();\n\n        emit AirdropClaimed(\n            msg.sender,\n            userHash,\n            airdropConfig.amountPerUser,\n            airdropConfig.requiredPolicyId\n        );\n    }\n\n    /**\n     * @notice Check if user can claim (verified and hasn't claimed yet)\n     * @param user User address\n     * @param userHash User identity hash\n     * @return bool True if can claim\n     */\n    function canClaim(address user, bytes32 userHash)\n        external\n        view\n        returns (bool)\n    {\n        if (!airdropConfig.active || hasClaimed[user]) {\n            return false;\n        }\n\n        uint256 remaining = airdropConfig.totalSupply - airdropConfig.claimed;\n        if (remaining < airdropConfig.amountPerUser) {\n            return false;\n        }\n\n        // Check verification\n        (bool success, bytes memory data) = verifierContract.staticcall(\n            abi.encodeWithSignature(\n                \"isVerified(bytes32,bytes32)\",\n                userHash,\n                airdropConfig.requiredPolicyId\n            )\n        );\n\n        return success && abi.decode(data, (bool));\n    }\n\n    /**\n     * @notice Update verifier contract address\n     * @param _verifier New verifier address\n     */\n    function setVerifier(address _verifier) external onlyOwner {\n        if (_verifier == address(0)) revert InvalidVerifier();\n        verifierContract = _verifier;\n    }\n\n    /**\n     * @notice Pause/unpause airdrop\n     * @param active New active state\n     */\n    function setActive(bool active) external onlyOwner {\n        airdropConfig.active = active;\n    }\n\n    /**\n     * @notice Withdraw remaining funds (owner only)\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        (bool sent, ) = payable(owner()).call{value: balance}(\"\");\n        if (!sent) revert TransferFailed();\n    }\n\n    /**\n     * @notice Get airdrop status\n     */\n    function getStatus() external view returns (\n        uint256 totalSupply,\n        uint256 claimed,\n        uint256 remaining,\n        bool active\n    ) {\n        return (\n            airdropConfig.totalSupply,\n            airdropConfig.claimed,\n            airdropConfig.totalSupply - airdropConfig.claimed,\n            airdropConfig.active\n        );\n    }\n\n    receive() external payable {}\n}\n\n"
    },
    "contracts/OmniPrivVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {OApp, Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title OmniPrivVerifier\n * @notice Chain B verifier - receives cross-chain verification flags via LayerZero\n * @dev Simplified receiver-only contract for demo dApps to query\n * Per OmniPriv 2.0 spec section 3: verified[userHash][policyId] = expiry\n */\ncontract OmniPrivVerifier is OApp {\n    // Events\n    event ClaimVerified(\n        bytes32 indexed userHash,\n        bytes32 indexed policyId,\n        uint64 expiry,\n        uint64 nonce,\n        uint32 sourceEid\n    );\n    \n    event NonceUpdated(\n        bytes32 indexed userHash,\n        bytes32 indexed policyId,\n        uint64 oldNonce,\n        uint64 newNonce\n    );\n\n    // State: verified[userHash][policyId] = expiry (per spec)\n    mapping(bytes32 => mapping(bytes32 => uint64)) public verified;\n    \n    // Nonce tracking per (userHash, policyId) to prevent replay\n    mapping(bytes32 => mapping(bytes32 => uint64)) public nonces;\n\n    // Errors\n    error InvalidMessage();\n    error ExpiredClaim();\n    error InvalidNonce();\n    error UntrustedRemote();\n\n    /**\n     * @notice Constructor\n     * @param _endpoint LayerZero endpoint address for this chain\n     * @param _owner Contract owner\n     */\n    constructor(address _endpoint, address _owner)\n        OApp(_endpoint, _owner)\n        Ownable(_owner)\n    {}\n\n    /**\n     * @notice Internal function to handle receiving messages from LayerZero\n     * @dev Receives: { userHash: bytes32, policyId: bytes32, expiry: uint64, nonce: uint64 }\n     * @param origin Message origin details\n     * @param message Encoded verification data\n     */\n    function _lzReceive(\n        Origin calldata origin,\n        bytes32, /*guid*/\n        bytes calldata message,\n        address, /*executor*/\n        bytes calldata /*extraData*/\n    ) internal override {\n        // Decode payload per spec section 3\n        (\n            bytes32 userHash,\n            bytes32 policyId,\n            uint64 expiry,\n            uint64 nonce\n        ) = abi.decode(message, (bytes32, bytes32, uint64, uint64));\n\n        // Validation per spec section 3\n        if (expiry <= block.timestamp) revert ExpiredClaim();\n        \n        // Nonce must be strictly increasing (prevent replay)\n        uint64 currentNonce = nonces[userHash][policyId];\n        if (nonce <= currentNonce) revert InvalidNonce();\n\n        // Update state\n        verified[userHash][policyId] = expiry;\n        nonces[userHash][policyId] = nonce;\n\n        emit ClaimVerified(userHash, policyId, expiry, nonce, origin.srcEid);\n        emit NonceUpdated(userHash, policyId, currentNonce, nonce);\n    }\n\n    /**\n     * @notice Check if user has valid verification for a policy\n     * @dev Primary interface for demo dApps per spec section 3\n     * @param userHash User identity hash (not wallet address)\n     * @param policyId Policy identifier (e.g., keccak256(\"AGE18_COUNTRY_ALLOWED\"))\n     * @return bool True if verified and not expired\n     */\n    function isVerified(bytes32 userHash, bytes32 policyId)\n        external\n        view\n        returns (bool)\n    {\n        uint64 expiry = verified[userHash][policyId];\n        return expiry > 0 && expiry > block.timestamp;\n    }\n\n    /**\n     * @notice Get expiry timestamp for a verification\n     * @param userHash User identity hash\n     * @param policyId Policy identifier\n     * @return uint64 Expiry timestamp (0 if not verified)\n     */\n    function getExpiry(bytes32 userHash, bytes32 policyId)\n        external\n        view\n        returns (uint64)\n    {\n        return verified[userHash][policyId];\n    }\n\n    /**\n     * @notice Get current nonce for (userHash, policyId)\n     * @param userHash User identity hash\n     * @param policyId Policy identifier\n     * @return uint64 Current nonce\n     */\n    function getNonce(bytes32 userHash, bytes32 policyId)\n        external\n        view\n        returns (uint64)\n    {\n        return nonces[userHash][policyId];\n    }\n}\n\n"
    },
    "contracts/ProofConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IVaultAnchor.sol\";\n\ninterface IIdentityOApp {\n    function sendVerification(\n        uint32 dstEid,\n        address user,\n        bytes32 policyId,\n        bytes32 commitment,\n        uint256 expiry,\n        bytes calldata options\n    ) external payable;\n}\n\n/**\n * @title ProofConsumer\n * @notice Verifies ZK proofs for credential predicates (e.g., age >= 18, KYC passed)\n * @dev In MVP, uses a simplified verification; production would use Noir verifier\n */\ncontract ProofConsumer is Ownable {\n    // Events\n    event ProofVerified(\n        address indexed user,\n        bytes32 indexed policyId,\n        bytes32 commitment,\n        bool success,\n        uint256 timestamp\n    );\n    event PolicyAdded(\n        bytes32 indexed policyId,\n        string schemaId,\n        address[] allowedIssuers\n    );\n    event ProofVerifiedAndBridged(\n        address indexed user,\n        bytes32 indexed policyId,\n        bytes32 commitment,\n        uint32 dstEid,\n        uint256 expiry\n    );\n\n    // Structs\n    struct Policy {\n        string schemaId;\n        address[] allowedIssuers;\n        bool active;\n    }\n\n    struct VerificationResult {\n        bool verified;\n        uint256 timestamp;\n        bytes32 commitment;\n        bytes32 policyId;\n    }\n\n    // State\n    IVaultAnchor public vaultAnchor;\n    IIdentityOApp public identityOApp;\n    mapping(bytes32 => Policy) public policies;\n    mapping(address => mapping(bytes32 => VerificationResult))\n        public verifications;\n    mapping(address => uint256) public nonces;\n\n    // Feature flags for MVP\n    bool public mockVerificationEnabled = true;\n\n    // Errors\n    error InvalidProof();\n    error PolicyNotFound();\n    error PolicyInactive();\n    error NonceAlreadyUsed();\n    error CommitmentInvalid();\n    error IdentityOAppNotSet();\n\n    constructor(address _vaultAnchor) Ownable(msg.sender) {\n        vaultAnchor = IVaultAnchor(_vaultAnchor);\n    }\n\n    /**\n     * @notice Add a verification policy\n     * @param policyId Unique policy identifier\n     * @param schemaId The credential schema (e.g., \"kyc_v1\", \"age_check\")\n     * @param allowedIssuers Array of allowed issuer addresses\n     */\n    function addPolicy(\n        bytes32 policyId,\n        string memory schemaId,\n        address[] memory allowedIssuers\n    ) external onlyOwner {\n        policies[policyId] = Policy({\n            schemaId: schemaId,\n            allowedIssuers: allowedIssuers,\n            active: true\n        });\n\n        emit PolicyAdded(policyId, schemaId, allowedIssuers);\n    }\n\n    /**\n     * @notice Verify a ZK proof for a given policy\n     * @param proof The ZK proof bytes (Noir proof in production)\n     * @param publicSignals Public signals: [commitment, policyId, nonce, ...]\n     * @param policyId The policy to verify against\n     * @return bool True if proof is valid\n     */\n    function verifyProof(\n        bytes calldata proof,\n        bytes32[] calldata publicSignals,\n        bytes32 policyId\n    ) public returns (bool) {\n        Policy memory policy = policies[policyId];\n        if (!policy.active) revert PolicyInactive();\n\n        // Extract public signals\n        bytes32 commitment = publicSignals[0];\n        uint256 nonce = uint256(publicSignals[2]);\n\n        // Check nonce (prevent replay)\n        if (nonce <= nonces[msg.sender]) revert NonceAlreadyUsed();\n        nonces[msg.sender] = nonce;\n\n        // Check commitment validity in VaultAnchor\n        if (!vaultAnchor.isCommitmentValid(msg.sender, commitment)) {\n            revert CommitmentInvalid();\n        }\n\n        // Verify proof (simplified for MVP)\n        bool verified = _verifyProofInternal(proof, publicSignals, policy);\n\n        if (verified) {\n            verifications[msg.sender][policyId] = VerificationResult({\n                verified: true,\n                timestamp: block.timestamp,\n                commitment: commitment,\n                policyId: policyId\n            });\n        }\n\n        emit ProofVerified(\n            msg.sender,\n            policyId,\n            commitment,\n            verified,\n            block.timestamp\n        );\n\n        return verified;\n    }\n\n    /**\n     * @notice Internal proof verification logic\n     * @dev For MVP with mockVerificationEnabled, always returns true\n     * @dev In production, this would call Noir/Aztec verifier contract\n     */\n    function _verifyProofInternal(\n        bytes calldata proof,\n        bytes32[] calldata publicSignals,\n        Policy memory policy\n    ) internal view returns (bool) {\n        if (mockVerificationEnabled) {\n            // Mock verification for demo\n            return proof.length > 0 && publicSignals.length >= 3;\n        }\n\n        // TODO: Call Noir verifier contract\n        // return noirVerifier.verify(proof, publicSignals);\n        revert(\"Production verifier not implemented\");\n    }\n\n    /**\n     * @notice Check if user has valid verification for a policy\n     * @param user The user address\n     * @param policyId The policy identifier\n     * @return bool True if verified and not expired\n     */\n    function isVerified(address user, bytes32 policyId)\n        external\n        view\n        returns (bool)\n    {\n        VerificationResult memory result = verifications[user][policyId];\n        return result.verified && result.timestamp > 0;\n    }\n\n    /**\n     * @notice Verify proof and bridge verification to another chain via LayerZero\n     * @dev Combines verifyProof with cross-chain bridging in one transaction\n     * @param proof The ZK proof bytes\n     * @param publicSignals Public signals from proof\n     * @param policyId The policy to verify against\n     * @param dstEid Destination LayerZero endpoint ID (Chain B)\n     * @param options LayerZero execution options\n     * @return bool True if proof verified successfully\n     */\n    function submitProofAndBridge(\n        bytes calldata proof,\n        bytes32[] calldata publicSignals,\n        bytes32 policyId,\n        uint32 dstEid,\n        bytes calldata options\n    ) external payable returns (bool) {\n        if (address(identityOApp) == address(0)) revert IdentityOAppNotSet();\n\n        // 1. Verify proof locally (stores result on Chain A)\n        bool verified = verifyProof(proof, publicSignals, policyId);\n        if (!verified) revert InvalidProof();\n\n        // 2. Extract data from public signals\n        bytes32 commitment = publicSignals[0];\n        \n        // 3. Calculate expiry (30 days from now)\n        uint256 expiry = block.timestamp + 30 days;\n\n        // 4. Send verification to Chain B via LayerZero\n        identityOApp.sendVerification{value: msg.value}(\n            dstEid,\n            msg.sender,\n            policyId,\n            commitment,\n            expiry,\n            options\n        );\n\n        emit ProofVerifiedAndBridged(\n            msg.sender,\n            policyId,\n            commitment,\n            dstEid,\n            expiry\n        );\n\n        return true;\n    }\n\n    /**\n     * @notice Toggle mock verification mode (owner only)\n     */\n    function setMockVerificationEnabled(bool enabled) external onlyOwner {\n        mockVerificationEnabled = enabled;\n    }\n\n    /**\n     * @notice Update vault anchor reference\n     */\n    function setVaultAnchor(address _vaultAnchor) external onlyOwner {\n        vaultAnchor = IVaultAnchor(_vaultAnchor);\n    }\n\n    /**\n     * @notice Set IdentityOApp address for cross-chain bridging\n     * @param _identityOApp Address of the IdentityOApp contract\n     */\n    function setIdentityOApp(address _identityOApp) external onlyOwner {\n        identityOApp = IIdentityOApp(_identityOApp);\n    }\n}\n\n"
    },
    "contracts/VaultAnchor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title VaultAnchor\n * @notice Stores commitment hashes for user credentials without revealing PII\n * @dev Each commitment is a Poseidon hash of (issuer_did, schema_id, salted_fields)\n */\ncontract VaultAnchor is Ownable, ReentrancyGuard {\n    // Events\n    event CommitmentAdded(\n        address indexed user,\n        bytes32 indexed commitment,\n        uint256 expiry,\n        uint256 timestamp\n    );\n    event CommitmentRevoked(\n        address indexed user,\n        bytes32 indexed commitment,\n        uint256 timestamp\n    );\n\n    // Structs\n    struct Commitment {\n        bytes32 commitment;\n        uint256 expiry;\n        uint256 timestamp;\n        bool revoked;\n    }\n\n    // State\n    mapping(address => mapping(bytes32 => Commitment)) public commitments;\n    mapping(address => bytes32[]) public userCommitments;\n\n    // Errors\n    error CommitmentAlreadyExists();\n    error CommitmentNotFound();\n    error CommitmentExpired();\n    error AlreadyRevoked();\n    error InvalidExpiry();\n    error ZeroCommitment();\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Add a new credential commitment\n     * @param commitment The Poseidon hash of the credential\n     * @param expiry Unix timestamp when the credential expires\n     */\n    function addCommitment(bytes32 commitment, uint256 expiry)\n        external\n        nonReentrant\n    {\n        if (commitment == bytes32(0)) revert ZeroCommitment();\n        if (expiry <= block.timestamp) revert InvalidExpiry();\n        if (commitments[msg.sender][commitment].commitment != bytes32(0)) {\n            revert CommitmentAlreadyExists();\n        }\n\n        commitments[msg.sender][commitment] = Commitment({\n            commitment: commitment,\n            expiry: expiry,\n            timestamp: block.timestamp,\n            revoked: false\n        });\n\n        userCommitments[msg.sender].push(commitment);\n\n        emit CommitmentAdded(msg.sender, commitment, expiry, block.timestamp);\n    }\n\n    /**\n     * @notice Revoke a credential commitment\n     * @param commitment The commitment hash to revoke\n     */\n    function revokeCommitment(bytes32 commitment) external nonReentrant {\n        Commitment storage c = commitments[msg.sender][commitment];\n        if (c.commitment == bytes32(0)) revert CommitmentNotFound();\n        if (c.revoked) revert AlreadyRevoked();\n\n        c.revoked = true;\n\n        emit CommitmentRevoked(msg.sender, commitment, block.timestamp);\n    }\n\n    /**\n     * @notice Check if a commitment is valid (exists, not expired, not revoked)\n     * @param user The user address\n     * @param commitment The commitment hash\n     * @return bool True if valid\n     */\n    function isCommitmentValid(address user, bytes32 commitment)\n        external\n        view\n        returns (bool)\n    {\n        Commitment memory c = commitments[user][commitment];\n        return\n            c.commitment != bytes32(0) &&\n            c.expiry > block.timestamp &&\n            !c.revoked;\n    }\n\n    /**\n     * @notice Get all commitments for a user\n     * @param user The user address\n     * @return bytes32[] Array of commitment hashes\n     */\n    function getUserCommitments(address user)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return userCommitments[user];\n    }\n\n    /**\n     * @notice Get commitment details\n     * @param user The user address\n     * @param commitment The commitment hash\n     * @return Commitment struct\n     */\n    function getCommitment(address user, bytes32 commitment)\n        external\n        view\n        returns (Commitment memory)\n    {\n        return commitments[user][commitment];\n    }\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}